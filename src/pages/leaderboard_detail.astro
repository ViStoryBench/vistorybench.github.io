---
import BaseLayout from "../layouts/BaseLayout.astro";
import { getAssetBase, buildAssetPath } from "../utils/path.ts";

const pageTitle = "Detailed Leaderboard";
const currentNav = "leaderboard_detail";
const assetBase = getAssetBase(Astro.url.pathname);
const chartScriptPath = buildAssetPath(assetBase, "js/chart.umd.js");
const chartScriptTag = `<script src="${chartScriptPath}"></script>`;

const fullDatasetTSV = `Method	model	mode	Cross CSD Score (Ref-Gen)	Self CSD Score (Gen-Gen)	Cross Cref Score (Ref-Gen)	Self Cref Score (Gen-Gen)	Aesthetics Score	Inception Score	OCCM	Scene	Camera	Global Character Action	Local/Single Character Action	Prompt Align Avg
Story image method	CharaConsist	Base	0.282101728	0.553242225	0.3152725	0.5186325	5.878994894	13.79612827	91.6358025	3.576667666	3.392475732	2.756921845	2.226666667	2.836
Story image method	OmniGen2	Base	0.453966918	0.600057826	0.54808375	0.64661375	5.249418215	11.0496645	96.75797625	3.484374273	3.428118927	2.874115189	2.6125	3.002
Story image method	QwenImageEdit2509	base	0.380702687	0.593238938	0.4751575	0.5738875	5.501412533	13.41742516	97.93709625	3.913092649	3.234621697	3.44021689	2.5375	3.133
Story image method	SeedStory	Base	0.226688106	0.748068074	0.287096154	0.586796154	3.824778534	6.303654671	93.14093974	1.962736126	1.828761781	0.457698773	0.666666667	1.117
Story image method	StoryAdapter	ImgRef_Scale0	0.455949334	0.548479901	0.45987125	0.60473625	4.994848698	12.9780941	95.37993	2.06600055	3.446392983	2.605591075	2.65	2.684
Story image method	StoryAdapter	ImgRef_Scale5	0.325291427	0.736620346	0.40109375	0.625555	4.88601606	13.72736168	97.83828875	1.925599026	3.280277642	2.551955191	2.4625	2.537
Story image method	StoryAdapter	TextOnly_Scale0	0.280088269	0.461685426	0.3998525	0.53842	5.174523708	16.34035873	97.0432425	2.128623345	3.437058718	2.684880001	2.5625	2.675
Story image method	StoryAdapter	TextOnly_Scale5	0.317937836	0.733205564	0.395215	0.6240875	4.90333285	13.13239574	97.80572	1.96369276	3.325108873	2.579889251	2.3375	2.509
Story image method	StoryDiffusion	ImgRef_Photomaker	0.340350785	0.5466562	0.43584875	0.5651725	5.125404203	10.0571909	97.92595375	2.004365489	3.445991242	2.642795583	2.675	2.689
Story image method	StoryDiffusion	Original	0.26935833	0.627685379	0.39666625	0.6216225	5.762796941	15.71576595	92.881695	3.177645672	3.092612461	1.987846549	1.875	2.402
Story image method	StoryGen	AutoRegressive	0.379493571	0.53958145	0.42760625	0.5755875	4.022261317	8.725982666	96.133745	1.157935634	2.248522056	1.426224884	1.9125	1.732
Story image method	StoryGen	Mix	0.282680611	0.579533097	0.41447625	0.59281	3.740455372	7.311157703	97.01079875	1.022627716	2.29887726	1.397113214	1.9625	1.729
Story image method	StoryGen	MultiImageCondition	0.370676669	0.531451248	0.41688625	0.56811375	4.021780138	8.891377449	96.6959825	1.260133706	2.288421301	1.422111998	1.7125	1.679
Story image method	TheaterGen	Base	0.184429483	0.391599551	0.347895	0.578215	4.896972486	14.88989925	92.74085125	2.764702067	1.811069182	0.925485257	1.0625	1.525
Story image method	UNO	Base	0.39098354	0.601657592	0.48458375	0.61971	5.231587752	12.40049267	98.5970875	3.509915128	3.246662728	2.792733115	2.475	2.900
Story video method	AnimDirector	SD3	0.28781174	0.510147267	0.40145	0.5784675	5.589688663	12.01537609	98.86376875	3.6431813	3.074853902	3.323970872	2.6875	3.083
Story video method	MMStoryAgent	Base	0.238202241	0.669013227	0.3881775	0.5957675	5.882790551	9.093803406	93.710235	2.924975944	2.611569623	1.850200579	1.625	2.127
Story video method	MovieAgent	ROICtrl	0.193143882	0.502232933	0.3603475	0.55989875	4.634387907	11.61257744	97.8165075	1.338974406	2.587652564	1.357143708	1.5125	1.662
Story video method	MovieAgent	SD3	0.299014463	0.478598833	0.4001375	0.54418125	5.318487555	14.98982716	98.811525	3.49514006	3.18413852	3.319517075	2.725	3.090
Story video method	Vlogger	ImgRef	0.258744665	0.452549425	0.36219375	0.55435	4.284577601	9.770858765	91.5694625	1.707219599	3.087474963	2.366335625	2.4375	2.407
Story video method	Vlogger	TextOnly	0.200743959	0.40650595	0.3460325	0.5475625	4.277468481	10.28503704	93.3329375	1.668860832	3.037219023	2.319041804	2.2375	2.300
`.trim();const 
liteDatasetTSV = `Method	model	mode	Cross CSD Score (Ref-Gen)	Self CSD Score (Gen-Gen)	Cross Cref Score (Ref-Gen)	Self Cref Score (Gen-Gen)	Aesthetics Score	Inception Score	OCCM	Scene	Camera	Global Character Action	Local/Single Character Action	Prompt Align Avg
Story image method	CharaConsist	Base	0.332958232	0.646050281	0.346805	0.53855	5.778289875	10.84172535	92.872905	3.690879372	3.611278195	2.8639915	2.210526316	2.917
Story image method	OmniGen2	Base	0.49088691	0.648067808	0.575795	0.667635	5.205899249	8.211501122	96.92178	3.49272976	3.294121339	2.961295254	2.55	2.970
Story image method	QwenImageEdit2509	base	0.404483591	0.614042177	0.48244	0.54108	5.460365499	10.55544472	97.63022	3.885191545	2.988917622	3.52504529	2.6	3.120
Story image method	SeedStory	Base	0.257923777	0.762734647	0.559489474	0.656031579	3.812115604	4.897685528	100.0	2.168518451	1.928351297	0.486188649	2.894736842	2.075
Story image method	StoryAdapter	ImgRef_Scale0	0.518357578	0.609331275	0.49042	0.604595	4.892279734	11.48530388	95.05803	1.91307617	3.439298973	2.558694991	2.7	2.662
Story image method	StoryAdapter	ImgRef_Scale5	0.371064473	0.757653784	0.42528	0.61925	4.803404408	12.02983761	97.363145	1.796660987	3.19763327	2.383665064	2.3	2.396
Story image method	StoryAdapter	TextOnly_Scale0	0.343325803	0.514571676	0.429745	0.547485	5.11979912	12.72167969	97.781435	1.965625674	3.422119576	2.736261719	2.65	2.685
Story image method	StoryAdapter	TextOnly_Scale5	0.353366091	0.751643874	0.4163	0.633755	4.851712874	10.59293747	97.235015	1.854368158	3.228329621	2.477149828	2.3	2.432
Story image method	StoryDiffusion	ImgRef_Photomaker	0.40901123	0.611355214	0.460465	0.57492	5.207344672	8.176711082	97.68906	1.910785618	3.414780069	2.639483995	2.75	2.693
Story image method	StoryDiffusion	Original	0.293280387	0.680224277	0.409125	0.640715	5.828540146	12.99354362	91.58502	3.210735233	2.997153933	1.920366815	1.95	2.406
Story image method	StoryGen	AutoRegressive	0.405437977	0.562215627	0.43706	0.59087	4.091010387	7.154542923	96.98627	1.050689991	2.323410961	1.431396094	1.75	1.661
Story image method	StoryGen	Mix	0.31614477	0.617440604	0.42872	0.60958	3.862157754	6.248496056	96.121835	0.887101632	2.411248686	1.386516452	2.05	1.757
Story image method	StoryGen	MultiImageCondition	0.396437858	0.551104372	0.420535	0.60194	4.088393089	7.669743061	97.627745	1.178295422	2.246119001	1.487879622	1.5	1.582
Story image method	TheaterGen	Base	0.22127979	0.410833261	0.354215	0.536725	4.943093552	13.60222054	90.213525	2.848989682	1.941898598	1.019353643	1.15	1.622
Story image method	UNO	Base	0.425227913	0.647670903	0.5115	0.630315	5.134146589	10.50181866	98.57377	3.542649098	3.154869438	2.976098521	2.55	2.955
Story video method	AnimDirector	SD3	0.30474288	0.557812691	0.422875	0.593185	5.602817362	9.942073822	99.029485	3.621959578	2.932399419	3.387767244	2.85	3.128
Story video method	MMStoryAgent	Base	0.260646785	0.661033769	0.384595	0.59783	5.910447238	8.089891434	90.64576	2.965248009	2.4517335	1.642740761	1.5	2.012
Story video method	MovieAgent	ROICtrl	0.235563366	0.564141511	0.371875	0.568145	4.688716209	10.0608139	96.982775	1.284257891	2.719711976	1.58405289	1.75	1.818
Story video method	MovieAgent	SD3	0.346310431	0.539476277	0.432535	0.582	5.317916727	12.0440979	99.472755	3.406009377	3.052264257	3.404355905	2.65	3.033
Story video method	Vlogger	ImgRef	0.298732243	0.496834425	0.372905	0.519085	4.242339268	8.827468872	90.845525	1.749048841	3.143481963	2.42859851	2.35	2.404
Story video method	Vlogger	TextOnly	0.239923022	0.461644385	0.368525	0.52414	4.239843533	8.408939362	93.32735	1.706868354	3.002645751	2.404205339	2.25	2.323
Commercial platform	AIbrm	Base	0.411924134	0.730196851	0.55679	0.7399	5.72123118	9.533270836	97.142725	3.5595439	3.053986806	2.53154723	2.05	2.649
Commercial platform	DouBao	Base	0.366719645	0.695391768	0.44598	0.642005	5.614623487	9.880890846	99.845885	3.976510989	3.228241096	3.769583263	2.95	3.375
Commercial platform	MOKI	Base	0.214389102	0.694267965	0.371755	0.62105	5.794278466	10.35705853	95.599705	2.883243777	1.876639047	0.936276185	1.1	1.579
Commercial platform	MorphicStudio	Base	0.577072922	0.628211553	0.602615789	0.676868421	4.956604087	9.003818512	99.37854737	3.362877966	3.072559567	2.656330181	2.105263158	2.660
Commercial platform	ShenBi	Base	0.274585337	0.575265148	0.417561111	0.585405556	5.069995527	11.60050774	98.74396111	3.787412323	2.805579041	3.454077688	2.722222222	3.098
Commercial platform	TypeMovie	Base	0.325036749	0.64637769	0.4643	0.621315	5.320682597	11.15472889	95.845935	2.86312367	3.001577493	2.60480446	2.3	2.614
MLLM model	Gemini	Base	0.361045845	0.572879374	0.572594118	0.677441176	4.906427097	10.11840534	99.81042353	3.564749243	3.260515449	3.197639952	3.294117647	3.322
MLLM model	GPT4o	Base	0.480765598	0.680078561	0.419826316	0.521910526	5.490427657	9.020773888	98.37864211	3.907062597	3.649050103	3.781113341	2.684210526	3.341
MLLM model	NanoBanana	Gemini2.5FlashImagePreview	0.446724217	0.657328133	0.55347	0.642145	5.611582331	10.54487324	99.77871	3.991071429	3.319035493	3.709418072	3.25	3.504
MLLM model	NanoBanana	Gemini3ProImagePreview	0.384753016	0.621867986	0.581045	0.65344	5.539814283	12.4985	93.55968	3.968600945	3.457954879	3.827714595	3.2	3.531
MLLM model	Seedream4	base	0.368798404	0.585419743	0.279536842	0.538947368	5.20844836	12.11877632	89.05277895	3.980523934	3.425904196	3.82314256	0.526315789	2.456
MLLM model	Sora2	ALL_ImgRef	0.514956351	0.713321149	0.765683333	0.83915	4.724243494	6.528349876	98.26675	3.446371276	3.286777438	3.427909346	2.5	3.032
MLLM model	Sora2	ALL_TextOnly	0.364737221	0.68488753	0.36398	0.56098	4.52029395	9.680335045	97.6101	3.237764925	3.355388043	3.438435726	2.866666667	3.153
`.trim();


interface DataRow {
    [key: string]: string;
}

interface ParsedTSVData {
    headers: string[];
    data: DataRow[];
}

function parseTSV(tsvString: string): ParsedTSVData {
    const lines = tsvString.trim().split("\n");
    const headers = lines[0]
        .split("\t")
        .map((h: string) => h.trim().replace(/^"|"$/g, "").replace(/\r$/, ""));
    const data = lines.slice(1).map((line: string) => {
        const values = line.split("\t");
        const row: DataRow = {};
        headers.forEach((header: string, index: number) => {
            row[header] = values[index]
                ? values[index].trim().replace(/^"|"$/g, "").replace(/\r$/, "")
                : "";
        });
        return row;
    });
    return { headers, data };
}

const fullResults = parseTSV(fullDatasetTSV);
const liteResults = parseTSV(liteDatasetTSV);

const bestOfModeData = {
    StoryAdapter: "ImgRef_Scale0",
    StoryDiffusion: "ImgRef_Photomaker",
    StoryGen: "MultiImageCondition",
    MovieAgent: "SD3",
    Vlogger: "TextOnly",
    Sora2: "ALL_ImgRef",
};
---

<BaseLayout title={pageTitle} activeNav={currentNav} assetBase={assetBase}>
    <Fragment set:html={chartScriptTag} />

    <style>
        @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap");

        .font-premium {
            font-family:
                "Inter",
                -apple-system,
                BlinkMacSystemFont,
                "Segoe UI",
                Roboto,
                Helvetica,
                Arial,
                sans-serif;
        }
        .font-mono-nums {
            font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo,
                Monaco, Consolas, monospace;
            font-feature-settings: "tnum";
            font-variant-numeric: tabular-nums;
        }

        /* Custom Scrollbar for table */
        .custom-scrollbar::-webkit-scrollbar {
            height: 10px;
            width: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1; /* slate-300 */
            border-radius: 5px;
            border: 2px solid transparent; /* creates padding around thumb */
            background-clip: content-box;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; /* slate-400 */
            border: 2px solid transparent;
            background-clip: content-box;
        }
        html.dark .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #475569; /* slate-600 */
        }
        html.dark .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* slate-500 */
        }

        .group-gradient-method-info {
            background-image: linear-gradient(
                120deg,
                rgba(99, 102, 241, 0.18),
                rgba(14, 165, 233, 0.18)
            );
        }
        html.dark .group-gradient-method-info {
            background-image: linear-gradient(
                120deg,
                rgba(79, 70, 229, 0.38),
                rgba(14, 165, 233, 0.32)
            );
        }

        .group-gradient-character {
            background-image: linear-gradient(
                120deg,
                rgba(236, 72, 153, 0.18),
                rgba(147, 51, 234, 0.15)
            );
        }
        html.dark .group-gradient-character {
            background-image: linear-gradient(
                120deg,
                rgba(236, 72, 153, 0.32),
                rgba(147, 51, 234, 0.28)
            );
        }

        .group-gradient-style {
            background-image: linear-gradient(
                120deg,
                rgba(16, 185, 129, 0.17),
                rgba(59, 130, 246, 0.15)
            );
        }
        html.dark .group-gradient-style {
            background-image: linear-gradient(
                120deg,
                rgba(16, 185, 129, 0.32),
                rgba(59, 130, 246, 0.28)
            );
        }

        .group-gradient-occm {
            background-image: linear-gradient(
                120deg,
                rgba(248, 113, 113, 0.18),
                rgba(251, 113, 133, 0.15)
            );
        }
        html.dark .group-gradient-occm {
            background-image: linear-gradient(
                120deg,
                rgba(248, 113, 113, 0.32),
                rgba(251, 113, 133, 0.28)
            );
        }

        .group-gradient-prompt {
            background-image: linear-gradient(
                120deg,
                rgba(59, 130, 246, 0.18),
                rgba(6, 182, 212, 0.15)
            );
        }
        html.dark .group-gradient-prompt {
            background-image: linear-gradient(
                120deg,
                rgba(59, 130, 246, 0.32),
                rgba(6, 182, 212, 0.28)
            );
        }

        .group-gradient-quality {
            background-image: linear-gradient(
                120deg,
                rgba(251, 191, 36, 0.18),
                rgba(34, 197, 94, 0.15)
            );
        }
        html.dark .group-gradient-quality {
            background-image: linear-gradient(
                120deg,
                rgba(251, 191, 36, 0.32),
                rgba(34, 197, 94, 0.28)
            );
        }
    </style>

    <div class="container mx-auto px-4 py-8 font-premium">
        <section
            id="charts-section"
            class="mb-10 p-6 bg-white dark:bg-slate-800 shadow-sm rounded-xl border border-gray-200 dark:border-slate-700"
        >
            <div
                class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4"
            >
                <h2
                    class="text-xl font-bold text-gray-900 dark:text-white tracking-tight"
                    data-lang-key="charts_title"
                >
                    Method Comparison Radar Charts
                </h2>
                <div class="flex flex-wrap items-center justify-end gap-4">
                    <div
                        class="flex items-center px-3 py-2 bg-gray-50 dark:bg-slate-700/50 rounded-lg border border-gray-100 dark:border-slate-600"
                    >
                        <input
                            id="best-of-method-checkbox"
                            type="checkbox"
                            class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 dark:border-slate-500 dark:bg-slate-700 dark:checked:bg-indigo-500 transition-colors"
                        />
                        <label
                            for="best-of-method-checkbox"
                            class="ml-2 block text-sm font-medium text-gray-700 dark:text-slate-200 cursor-pointer select-none"
                            data-lang-key="best_of_method_toggle"
                            >Best of Method Mode</label
                        >
                    </div>
                    <div
                        id="radar-mode-toggle-buttons"
                        class="flex bg-gray-100 dark:bg-slate-700 p-1 rounded-lg border border-gray-200 dark:border-slate-600"
                    >
                        <button
                            id="radar-lite-mode-btn"
                            class="px-4 py-1.5 rounded-md text-xs font-semibold uppercase tracking-wide transition-all duration-200"
                            data-lang-key="button_lite_mode">Lite</button
                        >
                        <button
                            id="radar-full-mode-btn"
                            class="px-4 py-1.5 rounded-md text-xs font-semibold uppercase tracking-wide transition-all duration-200"
                            data-lang-key="button_full_mode">Full</button
                        >
                    </div>
                </div>
            </div>
            <div
                id="radar-charts-container"
                class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-2 gap-8"
            >
                {/* Radar charts will be dynamically added here */}
            </div>
        </section>

        <section
            id="detailed-leaderboard-section"
            class="bg-white dark:bg-slate-800 shadow-md rounded-xl border border-gray-200 dark:border-slate-700 overflow-hidden"
        >
            <div
                class="p-6 border-b border-gray-100 dark:border-slate-700 bg-gray-50/50 dark:bg-slate-800/50 flex flex-col sm:flex-row justify-between items-center gap-4"
            >
                <h2
                    class="text-xl font-bold text-gray-900 dark:text-white tracking-tight"
                    data-lang-key="leaderboard_detail_results"
                >
                    Detailed Results
                </h2>
                <div
                    id="mode-toggle-buttons"
                    class="flex bg-gray-100 dark:bg-slate-700 p-1 rounded-lg border border-gray-200 dark:border-slate-600"
                >
                    <button
                        id="lite-mode-btn"
                        class="px-4 py-1.5 rounded-md text-xs font-semibold uppercase tracking-wide transition-all duration-200"
                        data-lang-key="button_lite_mode">Lite</button
                    >
                    <button
                        id="full-mode-btn"
                        class="px-4 py-1.5 rounded-md text-xs font-semibold uppercase tracking-wide transition-all duration-200"
                        data-lang-key="button_full_mode">Full</button
                    >
                </div>
            </div>

            <div class="overflow-x-auto custom-scrollbar">
                <table
                    id="detailed-leaderboard-table"
                    class="min-w-full bg-white dark:bg-slate-800 border-collapse"
                >
                    <thead id="leaderboard-thead">
                        {/* Headers will be rendered by script */}
                    </thead>
                    <tbody
                        id="leaderboard-tbody"
                        class="divide-y divide-gray-100 dark:divide-slate-700/50"
                    >
                        {/* Rows will be rendered by script */}
                    </tbody>
                </table>
            </div>
        </section>
    </div>
</BaseLayout>

<script
    define:vars={{
        fullResultsData: fullResults,
        liteResultsData: liteResults,
        bestOfModeData: bestOfModeData,
    }}
>
    let currentView = "lite"; // 'lite' or 'full'
    /** @type {DataRow[]} */
    let activeDataset = [...liteResultsData.data]; // Use spread to create a mutable copy for sorting
    /** @type {string[]} */
    let activeHeaders = liteResultsData.headers;

    const liteModeBtn = document.getElementById("lite-mode-btn");
    const fullModeBtn = document.getElementById("full-mode-btn");
    const tableThead = document.getElementById("leaderboard-thead");
    const tableTbody = document.getElementById("leaderboard-tbody");
    const leaderboardTable = document.getElementById(
        "detailed-leaderboard-table",
    );

    let columnStats = {};
    let isBestOfMethodMode = false;
    const bestOfMethodCheckbox = document.getElementById(
        "best-of-method-checkbox",
    );

    let currentSystemTheme = document.documentElement.classList.contains("dark")
        ? "dark"
        : "light";

    // Sorting State
    let currentSortColumnIndex = -1;
    let currentSortDirection = "asc";

    function getColumnType(header, sampleValue) {
        const numericHeaderKeywords = [
            "Score",
            "Avg",
            "OCCM",
            "CRef",
            "SRef",
            "Adh",
            "Quality",
            "Overall",
        ];
        const specificNumericHeaders = [
            "Cross CSD Score (Ref-Gen)",
            "Self CSD Score (Gen-Gen)",
            "Cross Cref Score (Ref-Gen)",
            "Self Cref Score (Gen-Gen)",
            "Aesthetics Score",
            "Inception Score",
            "Scene",
            "Camera",
            "Global Character Action",
            "Local/Single Character Action",
            "Prompt Align Avg",
            "OCCM",
        ];

        if (specificNumericHeaders.includes(header)) {
            if (
                sampleValue &&
                !isNaN(parseFloat(sampleValue)) &&
                isFinite(Number(sampleValue))
            ) {
                return "number";
            }
        }
        if (numericHeaderKeywords.some((keyword) => header.includes(keyword))) {
            if (
                sampleValue &&
                !isNaN(parseFloat(sampleValue)) &&
                isFinite(Number(sampleValue))
            ) {
                return "number";
            }
        }
        return "text";
    }

    // Define Color Schemes based on Method
    function getColorSettings(methodName) {
        const lowerMethod = methodName.toLowerCase();
        // HSL values: Hue, Saturation%, Lightness%
        if (lowerMethod.includes("story image")) {
            // Blueish (Based on #f0f8fd)
            return { h: 203, s: 100, l: 70 };
        } else if (lowerMethod.includes("story video")) {
            // Indigo/Purpleish (Based on #f7f7ff)
            return { h: 245, s: 100, l: 70 };
        } else if (lowerMethod.includes("mllm")) {
            // Reddish/Pinkish (Based on #fff2f2)
            return { h: 0, s: 100, l: 70 };
        } else if (lowerMethod.includes("commercial")) {
            // Peach/Orangeish (Based on #fdddd7)
            return { h: 15, s: 100, l: 70 };
        }
        // Default Gray
        return { h: 210, s: 10, l: 60 };
    }

    function calculateColumnStats() {
        columnStats = {};
        activeHeaders.forEach((header) => {
            const sampleValue =
                activeDataset.length > 0 ? activeDataset[0][header] : "";
            if (getColumnType(header, sampleValue) !== "number") return;
            let minVal = Infinity;
            let maxVal = -Infinity;
            let hasValue = false;
            activeDataset.forEach((row) => {
                const value = parseFloat(row[header]);
                if (!isNaN(value)) {
                    hasValue = true;
                    if (value < minVal) minVal = value;
                    if (value > maxVal) maxVal = value;
                }
            });
            if (hasValue) columnStats[header] = { min: minVal, max: maxVal };
        });
    }

    function renderTable() {
        if (!tableThead || !tableTbody) return;
        tableThead.innerHTML = "";
        tableTbody.innerHTML = "";
        calculateColumnStats();

        const groupHeaderRow = document.createElement("tr");
        const headerRow = document.createElement("tr");

        const dimensions = {
            "Method Info": ["Method", "model", "mode"],
            "Character Consistency": [
                "Cross Cref Score (Ref-Gen)",
                "Self Cref Score (Gen-Gen)",
            ],
            "Style Consistency": [
                "Cross CSD Score (Ref-Gen)",
                "Self CSD Score (Gen-Gen)",
            ],
            "OCCM": ["OCCM"],
            "Prompt Alignment": [
                "Scene",
                "Camera",
                "Global Character Action",
                "Local/Single Character Action",
                "Prompt Align Avg",
            ],
            "Quality & Diversity": ["Aesthetics Score", "Inception Score"],
        };

        const groupGradientClassMap = {
            "Method Info": "group-gradient-method-info",
            "Character Consistency": "group-gradient-character",
            "Style Consistency": "group-gradient-style",
            "OCCM": "group-gradient-occm",
            "Prompt Alignment": "group-gradient-prompt",
            "Quality & Diversity": "group-gradient-quality",
        };

        let currentGroup = "";
        let colspanCount = 0;
        let previousTh = null;

        activeHeaders.forEach((headerText, index) => {
            let groupNameForHeader = headerText;
            let isInAnyGroup = false;
            for (const group in dimensions) {
                if (dimensions[group].includes(headerText)) {
                    groupNameForHeader = group;
                    isInAnyGroup = true;
                    break;
                }
            }

            const isNewDisplayGroup = groupNameForHeader !== currentGroup;

            if (isNewDisplayGroup) {
                if (previousTh) {
                    previousTh.colSpan = colspanCount;
                }

                const groupTh = document.createElement("th");
                let groupThClass =
                    "py-2 px-4 text-center font-bold text-xs uppercase tracking-wider text-gray-700 dark:text-slate-200 bg-gray-100 dark:bg-slate-700/80 border-b border-gray-200 dark:border-slate-600";

                if (previousTh) {
                    groupThClass +=
                        " border-l border-white dark:border-slate-600";
                }
                groupTh.className = groupThClass;
                groupTh.textContent = isInAnyGroup ? groupNameForHeader : "";
                if (isInAnyGroup && groupGradientClassMap[groupNameForHeader]) {
                    groupTh.classList.add(
                        groupGradientClassMap[groupNameForHeader],
                    );
                }
                groupHeaderRow.appendChild(groupTh);

                previousTh = groupTh;
                currentGroup = groupNameForHeader;
                colspanCount = 1;
            } else {
                colspanCount++;
            }

            const th = document.createElement("th");
            th.className =
                "py-3 px-2 text-left cursor-pointer hover:bg-gray-100 dark:hover:bg-slate-700/80 transition-colors bg-white dark:bg-slate-800 text-gray-500 dark:text-slate-400 text-[10px] font-bold uppercase tracking-wider align-middle border-b border-gray-200 dark:border-slate-700 select-none";

            if (headerText === "Method")
                th.classList.add("w-24", "bg-gray-50", "dark:bg-slate-800/50");
            else if (headerText === "model")
                th.classList.add("w-32", "bg-gray-50", "dark:bg-slate-800/50");
            else if (headerText === "mode")
                th.classList.add("w-20", "bg-gray-50", "dark:bg-slate-800/50");
            else th.classList.add("min-w-[80px]");

            if (["Method", "model", "mode"].includes(headerText)) {
                th.classList.add(
                    "border-r",
                    "border-gray-100",
                    "dark:border-slate-700",
                );
            }

            const displayHeaderText = headerText
                .replace(" Score", "")
                .replace("Prompt Align ", "")
                .replace(" (Ref-Gen)", "")
                .replace(" (Gen-Gen)", "")
                .replace("（Alignment score）", "");

            th.textContent = displayHeaderText;

            const sampleValue =
                activeDataset.length > 0 && activeDataset[0]
                    ? activeDataset[0][headerText]
                    : "";
            const columnType = getColumnType(headerText, sampleValue);

            if (columnType === "number") {
                th.classList.add("text-center");
            }

            th.dataset.sortable = columnType;
            th.dataset.columnIndex = String(index);

            const arrowSpan = document.createElement("span");
            arrowSpan.className = "sort-arrow ml-1 inline-block w-3";
            th.appendChild(arrowSpan);

            th.addEventListener("click", () => sortTable(index, columnType));
            headerRow.appendChild(th);
        });

        if (previousTh) {
            previousTh.colSpan = colspanCount;
        }

        tableThead.appendChild(groupHeaderRow);
        tableThead.appendChild(headerRow);
        updateSortIndicators(
            leaderboardTable,
            currentSortColumnIndex,
            currentSortDirection,
        );

        // === RENDER ROWS ===
        activeDataset.forEach((rowData, rowIndex) => {
            const tr = document.createElement("tr");
            tr.className =
                "group hover:bg-gray-50 dark:hover:bg-slate-700/30 transition-colors duration-75";

            // Determine Row Base Color Scheme
            const colorSettings = getColorSettings(rowData["Method"]);

            activeHeaders.forEach((header) => {
                let shouldRenderCell = true;
                let calculatedRowspan = 1;

                if (["Method", "model"].includes(header)) {
                    if (
                        currentSortColumnIndex === -1 ||
                        getColumnType(
                            activeHeaders[currentSortColumnIndex],
                            "0",
                        ) !== "number"
                    ) {
                        if (header === "Method") {
                            if (
                                rowIndex > 0 &&
                                rowData["Method"] ===
                                    activeDataset[rowIndex - 1]["Method"]
                            ) {
                                shouldRenderCell = false;
                            } else {
                                for (
                                    let i = rowIndex + 1;
                                    i < activeDataset.length;
                                    i++
                                ) {
                                    if (
                                        activeDataset[i]["Method"] ===
                                        rowData["Method"]
                                    )
                                        calculatedRowspan++;
                                    else break;
                                }
                            }
                        } else if (header === "model") {
                            if (
                                rowIndex > 0 &&
                                rowData["Method"] ===
                                    activeDataset[rowIndex - 1]["Method"] &&
                                rowData["model"] ===
                                    activeDataset[rowIndex - 1]["model"]
                            ) {
                                shouldRenderCell = false;
                            } else {
                                for (
                                    let i = rowIndex + 1;
                                    i < activeDataset.length;
                                    i++
                                ) {
                                    if (
                                        activeDataset[i]["Method"] !==
                                        rowData["Method"]
                                    )
                                        break;
                                    if (
                                        activeDataset[i]["model"] ===
                                        rowData["model"]
                                    )
                                        calculatedRowspan++;
                                    else break;
                                }
                            }
                        }
                    }
                }

                if (shouldRenderCell) {
                    const td = document.createElement("td");
                    let cellValue =
                        rowData[header] !== undefined
                            ? String(rowData[header])
                            : "";

                    // Base Style: ensure vertical alignment is middle
                    let baseTdClass =
                        "py-2 px-2 text-sm border-b border-gray-100 dark:border-slate-800 align-middle";

                    if (header === "Method") {
                        // align-middle handles vertical centering for rowspan
                        td.className =
                            baseTdClass +
                            " w-24 text-xs font-bold text-gray-900 dark:text-slate-100 bg-gray-50 dark:bg-slate-800/50 border-r border-gray-200 dark:border-slate-700";
                        cellValue = cellValue
                            .replace(/ method$/i, "")
                            .replace(/ platform$/i, "")
                            .replace("Story image", "Story Image")
                            .replace("Story video", "Story Video");
                    } else if (header === "model") {
                        td.className =
                            baseTdClass +
                            " w-32 text-xs font-semibold text-gray-700 dark:text-slate-300 bg-gray-50/30 dark:bg-slate-800/30 border-r border-gray-200 dark:border-slate-700 break-words";
                    } else if (header === "mode") {
                        td.className =
                            baseTdClass +
                            " w-20 text-xs text-gray-500 dark:text-slate-400 border-r border-gray-100 dark:border-slate-700/50";
                    } else {
                        td.className = baseTdClass;
                    }

                    if (calculatedRowspan > 1) {
                        td.rowSpan = calculatedRowspan;
                        td.classList.add(
                            "border-b-2",
                            "border-gray-200",
                            "dark:border-slate-600",
                        );
                    }

                    const columnType = getColumnType(header, cellValue);

                    if (columnType === "number") {
                        td.classList.add("text-center", "font-mono-nums");

                        const numericValue = parseFloat(cellValue);
                        if (!isNaN(numericValue)) {
                            const stats = columnStats[header];
                            let normalizedValue = 0.5;
                            if (stats && stats.max !== stats.min) {
                                normalizedValue =
                                    (numericValue - stats.min) /
                                    (stats.max - stats.min);
                            }
                            normalizedValue = Math.max(
                                0,
                                Math.min(1, normalizedValue),
                            );

                            // === COLOR LOGIC BASED ON METHOD ===
                            const isDarkMode =
                                document.documentElement.classList.contains(
                                    "dark",
                                );

                            // Range opacity based on value (0.05 to 0.5)
                            const opacity = 0.05 + normalizedValue * 0.45;

                            // Construct HSLA color
                            const { h, s, l } = colorSettings;

                            if (isDarkMode) {
                                // Dark Mode: Keep hue, darken lightness for bg, lighten for text
                                td.style.backgroundColor = `hsla(${h}, ${s}%, 25%, ${opacity + 0.1})`;
                                td.style.color = `hsl(${h}, 80%, 90%)`;
                                if (normalizedValue > 0.8)
                                    td.classList.add("font-bold");
                            } else {
                                // Light Mode: Use standard calculated HSL
                                td.style.backgroundColor = `hsla(${h}, ${s}%, ${l}%, ${opacity})`;

                                // Text Color Contrast
                                // For very light backgrounds, use dark gray. For stronger backgrounds, use dark saturated color
                                if (normalizedValue < 0.3) {
                                    td.style.color = "#64748b"; // Slate-500
                                } else {
                                    td.style.color = `hsl(${h}, 100%, 20%)`; // Very dark version of the hue
                                }

                                if (normalizedValue > 0.8)
                                    td.classList.add("font-bold");
                            }

                            td.textContent = numericValue.toFixed(3);
                        } else {
                            td.textContent = cellValue;
                        }
                    } else {
                        td.textContent = cellValue.replace("\n", " ");
                    }
                    tr.appendChild(td);
                }
            });
            tableTbody.appendChild(tr);
        });
    }

    // [Rest of the Chart Code and Event Listeners remain same...]
    function updateButtonState(btn, isActive) {
        const activeClasses = [
            "bg-indigo-600",
            "text-white",
            "shadow-md",
            "border-transparent",
        ];
        const inactiveClasses = [
            "text-gray-600",
            "hover:bg-gray-200",
            "dark:text-slate-300",
            "dark:hover:bg-slate-600",
            "border-transparent",
        ];

        if (isActive) {
            btn.classList.remove(...inactiveClasses);
            btn.classList.add(...activeClasses);
        } else {
            btn.classList.remove(...activeClasses);
            btn.classList.add(...inactiveClasses);
        }
    }

    function updateAllButtonStyles() {
        const radarLite = document.getElementById("radar-lite-mode-btn");
        const radarFull = document.getElementById("radar-full-mode-btn");
        if (radarLite && radarFull) {
            updateButtonState(radarLite, currentView === "lite");
            updateButtonState(radarFull, currentView === "full");
        }

        const tableLite = document.getElementById("lite-mode-btn");
        const tableFull = document.getElementById("full-mode-btn");
        if (tableLite && tableFull) {
            updateButtonState(tableLite, currentView === "lite");
            updateButtonState(tableFull, currentView === "full");
        }
    }

    // Radar Chart Logic (Simplified for brevity, ensures update works)
    let radarChartInstances = {};
    const radarChartsContainer = document.getElementById(
        "radar-charts-container",
    );
    let radarMetricsStats = {};

    function getDynamicRadarMetrics() {
        const excludedMetrics = ["ID", "RowNumber"];
        const metrics = activeHeaders.filter((header) => {
            const sampleValue =
                activeDataset.length > 0 && activeDataset[0]
                    ? activeDataset[0][header]
                    : "";
            return (
                getColumnType(header, sampleValue) === "number" &&
                !excludedMetrics.includes(header)
            );
        });
        return metrics.sort();
    }

    function calculateAllRadarMetricsStats(metrics) {
        radarMetricsStats = {};
        metrics.forEach((metric) => {
            let minVal = Infinity;
            let maxVal = -Infinity;
            let count = 0;
            activeDataset.forEach((row) => {
                const value = parseFloat(row[metric]);
                if (!isNaN(value)) {
                    if (value < minVal) minVal = value;
                    if (value > maxVal) maxVal = value;
                    count++;
                }
            });
            if (count > 0) {
                if (minVal === maxVal) {
                    radarMetricsStats[metric] = {
                        min: minVal - 0.5,
                        max: maxVal + 0.5,
                    };
                    if (minVal === 0)
                        radarMetricsStats[metric] = { min: -0.5, max: 0.5 };
                } else {
                    radarMetricsStats[metric] = { min: minVal, max: maxVal };
                }
            } else {
                radarMetricsStats[metric] = { min: 0, max: 1 };
            }
        });
    }

    function prepareSingleRadarData(
        methodName,
        modelRowsDataForMethod,
        radarMetricsForChart,
    ) {
        const datasets = [];
        let modelsToProcess = modelRowsDataForMethod;

        if (isBestOfMethodMode) {
            const uniqueModelNamesInMethod = [
                ...new Set(modelRowsDataForMethod.map((r) => r.model)),
            ];
            const finalRowsForChart = [];
            uniqueModelNamesInMethod.forEach((modelName) => {
                const bestModeForThisModel = bestOfModeData[modelName];
                if (bestModeForThisModel) {
                    const bestRow = modelRowsDataForMethod.find(
                        (r) =>
                            r.model === modelName &&
                            r.mode === bestModeForThisModel,
                    );
                    if (bestRow) finalRowsForChart.push(bestRow);
                } else {
                    const allModesForThisModel = modelRowsDataForMethod.filter(
                        (r) => r.model === modelName,
                    );
                    finalRowsForChart.push(...allModesForThisModel);
                }
            });
            modelsToProcess = finalRowsForChart;
        }

        modelsToProcess.forEach((modelRow, index) => {
            const label = `${modelRow.model} (${modelRow.mode})`;
            const originalValues = {};
            const normalizedDataValues = radarMetricsForChart.map((metric) => {
                const rawValue = parseFloat(modelRow[metric]);
                originalValues[metric] = !isNaN(rawValue) ? rawValue : "N/A";
                const stats = radarMetricsStats[metric];
                if (isNaN(rawValue) || !stats) return 0;
                if (stats.max === stats.min) return 0.5;
                const normalized =
                    (rawValue - stats.min) / (stats.max - stats.min);
                return Math.max(0, Math.min(1, normalized));
            });

            const colors = [
                { border: "#4f46e5", bg: "rgba(79, 70, 229, 0.1)" },
                { border: "#0ea5e9", bg: "rgba(14, 165, 233, 0.1)" },
                { border: "#10b981", bg: "rgba(16, 185, 129, 0.1)" },
                { border: "#f59e0b", bg: "rgba(245, 158, 11, 0.1)" },
                { border: "#ec4899", bg: "rgba(236, 72, 153, 0.1)" },
            ];
            const colorObj = colors[index % colors.length];

            datasets.push({
                label: label,
                data: normalizedDataValues,
                _originalValues: originalValues,
                backgroundColor: colorObj.bg,
                borderColor: colorObj.border,
                borderWidth: 2,
                pointBackgroundColor: colorObj.border,
                pointRadius: 0,
                pointHoverRadius: 4,
            });
        });

        return {
            labels: radarMetricsForChart.map((m) =>
                m
                    .replace(/ \(.*?\)/g, "")
                    .replace(" Score", "")
                    .replace("Prompt Align ", "")
                    .substring(0, 12),
            ),
            datasets: datasets,
        };
    }

    function renderOrUpdateAllRadarCharts() {
        if (!radarChartsContainer) return;
        radarChartsContainer.innerHTML = "";
        Object.values(radarChartInstances).forEach((instance) =>
            instance.destroy(),
        );
        radarChartInstances = {};

        const radarMetricsForChart = getDynamicRadarMetrics();
        if (radarMetricsForChart.length === 0) return;

        calculateAllRadarMetricsStats(radarMetricsForChart);
        const methods = [
            ...new Set(activeDataset.map((row) => row.Method)),
        ].filter((m) => m !== "NaiveBaseline");

        methods.forEach((methodName, chartIndex) => {
            const methodDataRows = activeDataset.filter(
                (row) => row.Method === methodName,
            );
            if (methodDataRows.length === 0) return;

            const chartId = `radarChart-${chartIndex}`;
            const canvasContainer = document.createElement("div");
            canvasContainer.className =
                "relative h-[400px] p-5 rounded-xl bg-white dark:bg-slate-800 flex flex-col border border-gray-100 dark:border-slate-700 hover:shadow-lg transition-shadow duration-300";

            const title = document.createElement("h3");
            title.className =
                "text-sm font-bold text-center mb-2 text-gray-700 dark:text-slate-200 uppercase tracking-wide";
            title.textContent = methodName.replace(" method", "");
            canvasContainer.appendChild(title);

            const canvasWrapper = document.createElement("div");
            canvasWrapper.className = "flex-1 relative min-h-0";
            const canvas = document.createElement("canvas");
            canvas.id = chartId;
            canvasWrapper.appendChild(canvas);
            canvasContainer.appendChild(canvasWrapper);
            radarChartsContainer.appendChild(canvasContainer);

            const chartData = prepareSingleRadarData(
                methodName,
                methodDataRows,
                radarMetricsForChart,
            );
            const ctx = canvas.getContext("2d");

            if (ctx) {
                const isDark =
                    document.documentElement.classList.contains("dark");
                const gridColor = isDark
                    ? "rgba(148, 163, 184, 0.1)"
                    : "rgba(0, 0, 0, 0.05)";
                const pointLabelColor = isDark ? "#94a3b8" : "#64748b";

                radarChartInstances[methodName] = new Chart(ctx, {
                    type: "radar",
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            r: {
                                angleLines: { color: gridColor },
                                grid: { color: gridColor },
                                suggestedMin: 0,
                                suggestedMax: 1,
                                pointLabels: {
                                    font: {
                                        size: 10,
                                        family: "'Inter', sans-serif",
                                        weight: 600,
                                    },
                                    color: pointLabelColor,
                                },
                                ticks: { display: false },
                            },
                        },
                        plugins: {
                            legend: {
                                position: "bottom",
                                labels: {
                                    usePointStyle: true,
                                    boxWidth: 6,
                                    padding: 15,
                                    font: {
                                        size: 10,
                                        family: "'Inter', sans-serif",
                                    },
                                    color: pointLabelColor,
                                },
                            },
                            tooltip: {
                                backgroundColor: isDark
                                    ? "rgba(15, 23, 42, 0.95)"
                                    : "rgba(255, 255, 255, 0.95)",
                                titleColor: isDark ? "#f1f5f9" : "#0f172a",
                                bodyColor: isDark ? "#cbd5e1" : "#334155",
                                borderColor: isDark ? "#334155" : "#e2e8f0",
                                borderWidth: 1,
                                padding: 10,
                                bodyFont: {
                                    family: "'JetBrains Mono', monospace",
                                },
                                callbacks: {
                                    label: function (context) {
                                        const metricName =
                                            radarMetricsForChart[
                                                context.dataIndex
                                            ];
                                        const originalValue =
                                            context.dataset._originalValues[
                                                metricName
                                            ];
                                        const valDisplay =
                                            originalValue !== undefined &&
                                            originalValue !== "N/A"
                                                ? Number(originalValue).toFixed(
                                                      3,
                                                  )
                                                : originalValue;
                                        return `${context.dataset.label}: ${valDisplay}`;
                                    },
                                },
                            },
                        },
                    },
                });
            }
        });
    }

    function renderAll() {
        renderTable();
        renderOrUpdateAllRadarCharts();
    }

    bestOfMethodCheckbox?.addEventListener("change", (event) => {
        isBestOfMethodMode = event.target.checked;
        renderOrUpdateAllRadarCharts();
    });

    function switchMode(mode) {
        if (currentView === mode) return;
        currentView = mode;
        const sourceData = mode === "lite" ? liteResultsData : fullResultsData;
        activeDataset = [...sourceData.data];
        activeHeaders = sourceData.headers;
        currentSortColumnIndex = -1;
        currentSortDirection = "asc";
        updateAllButtonStyles();
        renderAll();
    }

    ["radar-lite-mode-btn", "lite-mode-btn"].forEach((id) => {
        document
            .getElementById(id)
            ?.addEventListener("click", () => switchMode("lite"));
    });
    ["radar-full-mode-btn", "full-mode-btn"].forEach((id) => {
        document
            .getElementById(id)
            ?.addEventListener("click", () => switchMode("full"));
    });

    document.addEventListener("DOMContentLoaded", () => {
        if (bestOfMethodCheckbox)
            isBestOfMethodMode = bestOfMethodCheckbox.checked;
        updateAllButtonStyles();
        renderAll();
        const observer = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (
                    mutation.type === "attributes" &&
                    mutation.attributeName === "class"
                ) {
                    const newTheme =
                        document.documentElement.classList.contains("dark")
                            ? "dark"
                            : "light";
                    if (newTheme !== currentSystemTheme) {
                        currentSystemTheme = newTheme;
                        renderAll();
                    }
                }
            }
        });
        observer.observe(document.documentElement, { attributes: true });
    });

    function sortTable(columnIndex, type) {
        const headerKey = activeHeaders[columnIndex];
        if (currentSortColumnIndex === columnIndex) {
            currentSortDirection =
                currentSortDirection === "asc" ? "desc" : "asc";
        } else {
            currentSortColumnIndex = columnIndex;
            currentSortDirection = "desc";
        }
        activeDataset.sort((a, b) => {
            let valA = a[headerKey];
            let valB = b[headerKey];
            if (type === "number") {
                valA = parseFloat(valA);
                valB = parseFloat(valB);
                if (isNaN(valA)) valA = -Infinity;
                if (isNaN(valB)) valB = -Infinity;
            } else {
                valA = valA ? valA.toString().toLowerCase() : "";
                valB = valB ? valB.toString().toLowerCase() : "";
            }
            if (valA < valB) return currentSortDirection === "asc" ? -1 : 1;
            if (valA > valB) return currentSortDirection === "asc" ? 1 : -1;
            return 0;
        });
        renderTable();
    }

    function updateSortIndicators(table, activeColumnIndex, direction) {
        if (!table) return;
        table
            .querySelectorAll("thead th[data-sortable]")
            .forEach((thElement) => {
                const th = thElement;
                const arrow = th.querySelector(".sort-arrow");
                if (!arrow) return;

                arrow.textContent = "";
                th.classList.remove(
                    "text-indigo-600",
                    "dark:text-indigo-400",
                    "bg-gray-100",
                    "dark:bg-slate-700",
                );

                if (
                    th.dataset.columnIndex &&
                    parseInt(th.dataset.columnIndex) === activeColumnIndex
                ) {
                    arrow.textContent = direction === "asc" ? " ↑" : " ↓";
                    arrow.classList.add(
                        "text-indigo-600",
                        "dark:text-indigo-400",
                    );
                    th.classList.add(
                        "bg-gray-100",
                        "dark:bg-slate-700",
                        "text-indigo-600",
                        "dark:text-indigo-400",
                    );
                }
            });
    }
</script>
