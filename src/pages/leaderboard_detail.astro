---
import BaseLayout from '../layouts/BaseLayout.astro';

const pageTitle = "Detailed Leaderboard"; // Translations will apply to this via data-lang-key in Header
const currentNav = "leaderboard_detail";

// Data provided by user - TSV format
const fullDatasetTSV = `Method	model	mode	Cross CSD Score (Ref-Gen)	Self CSD Score (Gen-Gen)	Cross Cref Score (Ref-Gen)	Self Cref Score (Gen-Gen)	Aesthetics Score	Inception Score	Prompt Align (Scene)	Prompt Align (Camera)	Prompt Align (Character Existence|Number) OCCM	Prompt Align (Global Character Action|Script)	Prompt Align (Local/Single Character Action|Script)	Prompt Align Avg
Story image method	Omnigen2	base	0.45396691756626906	0.600057826206508	0.53744	0.6526912500000002	5.249418214826132	11.049664497375488	3.462769350612126	3.383498929079289	90.81085125	2.816634083246491	2.4125	3.019
Story image method	Seedstory	base	0.2266881057854613	0.7480680735925421	0.24892948717948712	0.5273423076923076	3.8247785344768093	6.303654670715332	1.96273612552232	1.828761781455463	77.84803846153848	0.45769877332075226	0.5384615384615384	1.197
Story image method	Storyadapter	(Img ref)(scale0)	0.45594933406141447	0.5484799006223571	0.43043249999999994	0.6052712500000001	4.994848698295852	12.978094100952148	2.0660005503441807	3.4463929828631192	86.31226125000003	2.6055910745695554	2.4375	2.639
Story image method	Storyadapter	(Img ref)(scale5)	0.32529142729613464	0.736620346007346	0.3405337500000001	0.5904937499999999	4.886016059770492	13.727361679077148	1.9255990264376515	3.280277642035756	85.74491249999998	2.5519551907438194	2.3	2.514
Story image method	Storyadapter	text only (xl)	0.28008826893025573	0.46168542626800474	0.361815	0.5268762500000002	5.174523708293563	16.34035873413086	2.12862334508074	3.4370587184063077	85.63308874999998	2.684880001480938	2.4375	2.672
Story image method	Storyadapter	text only (xl5)	0.31793783588816066	0.7332055636810979	0.335975	0.5796250000000002	4.903332849961927	13.13239574432373	1.9636927598367548	3.3251088732982788	86.34694000000002	2.5798892510642117	2.3625	2.558
Story image method	Storydiffusion	(Img ref) (photomaker)	0.34035078514500894	0.5466561996518988	0.3982850000000001	0.5813775000000002	5.12540420297368	10.057190895080566	2.004365489384767	3.4459912420716337	84.91701125000003	2.642795583050887	2.5875	2.670
Story image method	Storydiffusion	original	0.2693583296002462	0.6276853790398238	0.36302625	0.59495375	5.762796941242485	15.715765953063965	3.1776456716498336	3.0926124609790544	83.79789124999999	1.9878465492859647	1.9625	2.555
Story image method	Storygen	auto-regressive	0.37949357096519354	0.539581449527207	0.394955	0.5538775000000001	4.022261317017248	8.725982666015625	1.157935634008769	2.2485220555200116	79.6183	1.4262248841528964	1.575	1.602
Story image method	Storygen	mix	0.2826806107202498	0.5795330969409931	0.368525	0.5731225	3.740455372122404	7.311157703399658	1.0226277159325903	2.2988772603774876	81.04991625	1.3971132142628273	1.7	1.605
Story image method	Storygen	multi-image-condition	0.3706766686921917	0.5314512483722901	0.37076624999999996	0.5123274999999999	4.021780137761007	8.891377449035645	1.2601337057464903	2.288421300883835	80.26310875000001	1.4221119978474654	1.6625	1.658
Story image method	Theatergen	base	0.18442948342237936	0.391599551048337	0.3144274999999999	0.5416274999999998	4.8969724862175585	14.889899253845215	2.7647020666323994	1.8110691817387192	78.10410875	0.9254852568223125	1.0	1.625
Story image method	UNO	base	0.39098353966909466	0.6016575917468682	0.457425	0.6090050000000001	5.231587752426296	12.400492668151855	3.5099151276328384	3.2466627281653593	89.49043000000003	2.7927331146544594	2.375	2.981
Story video method	Animdirector	base	0.28781174034698204	0.5101472671963534	0.37032374999999995	0.5552575	5.589688663362523	12.015376091003418	3.643181299782506	3.0748539020056276	86.81175125	3.3239708718635415	2.5625	3.151
Story video method	MM-StoryAgent	base	0.23820224087025282	0.6690132274237905	0.3505224999999999	0.5612774999999998	5.882790551455916	9.093803405761719	2.9249759438398883	2.6115696234792023	82.56375499999999	1.8502005785398672	1.45	2.209
Story video method	Movieagent	ROICtrl version	0.19314388170718805	0.502232933289761	0.31448124999999993	0.5071899999999999	4.634387907089943	11.612577438354492	1.3389744061176134	2.587652563643579	84.67861249999996	1.3571437077666937	1.2875	1.643
Story video method	Movieagent	SD-3 version	0.29901446300621143	0.47859883270648584	0.37348250000000005	0.5268349999999998	5.3184875547723625	14.989827156066895	3.4951400598232283	3.184138519925517	87.84409625	3.3195170751493945	2.6375	3.159
Story video method	Vlogger	img ref	0.2587446652815063	0.4525494246047105	0.33592874999999994	0.5422062500000002	4.284577600993049	9.770858764648438	1.7072195986953365	3.087474962998839	83.95820375000001	2.3663356253893406	2.3125	2.368
Story video method	Vlogger	text only	0.2007439587437223	0.4065059499350028	0.3088149999999999	0.5019037500000001	4.2774684805325	10.28503704071045	1.6688608321382836	3.0372190231750356	83.82743624999999	2.319041803712727	2.1875	2.303
Naive baseline	Naive baseline	base	0.7283165056992451	0.7119139375132899	0.9253037499999998	0.98377125	4.475803482013562	6.708273410797119	0.5748529840221287	2.2132365345847047	99.701535	0.7975031420707169	1.3375	1.231
`.trim();const liteDatasetTSV = `Method	model	mode	Cross CSD Score (Ref-Gen)	Self CSD Score (Gen-Gen)	Cross Cref Score (Ref-Gen)	Self Cref Score (Gen-Gen)	Aesthetics Score	Inception Score	Prompt Align (Scene)	Prompt Align (Camera)	Prompt Align (Character Existence|Number) OCCM	Prompt Align (Global Character Action|Script)	Prompt Align (Local/Single Character Action|Script)	Prompt Align Avg（Alignment score）
Story image method	Omnigen2	base	0.4908869097614085	0.6480678082414152	0.5681499999999999	0.67001	5.205899249326583	8.211501121520996	3.5205198050937967	3.2685937266634513	90.32323999999998	2.9288223477164395	2.55	3.067
Story image method	Seedstory	base	0.25792377664037186	0.7627346469456694	0.2362368421052631	0.5144473684210527	3.8121156041226585	4.897685527801514	2.168518450858605	1.9283512970405554	73.25415789473684	0.48618864937279255	0.42105263157894735	1.251
Story image method	Storyadapter	(Img ref)(scale0)	0.518357578414683	0.6093312752638863	0.4439250000000001	0.5823750000000001	4.892279734129177	11.48530387878418	1.913076169875059	3.439298972502441	84.04894500000003	2.5586949913981862	2.45	2.590
Story image method	Storyadapter	(Img ref)(scale5)	0.3710644731898233	0.7576537839682408	0.329425	0.5660899999999999	4.803404408128485	12.029837608337402	1.796660986928665	3.1976332703558112	81.55917	2.3836650637011734	2.2	2.394
Story image method	Storyadapter	text only (xl)	0.34332580333507523	0.5145716761393451	0.375345	0.5004199999999999	5.11979911981716	12.7216796875	1.9656256743698808	3.4221195760295346	84.42287000000002	2.7362617193143564	2.6	2.681
Story image method	Storyadapter	text only (xl5)	0.3533660907758909	0.7516438743677043	0.33533500000000005	0.546225	4.851712874136384	10.592937469482422	1.8543681577752722	3.228329620761052	84.32804999999999	2.477149827851265	2.25	2.452
Story image method	Storydiffusion	(Img ref) (photomaker)	0.40901122956529345	0.6113552136593438	0.37857499999999994	0.5533299999999999	5.2073446720806285	8.176711082458496	1.9107856183858813	3.414780069222849	82.529255	2.6394839948100985	2.7	2.666
Story image method	Storydiffusion	original	0.29328038689011116	0.6802242769068043	0.34364999999999996	0.523555	5.828540145663008	12.99354362487793	3.210735232970621	2.9971539325978593	80.52278499999998	1.920366814748688	2.0	2.532
Story image method	Storygen	auto-regressive	0.40543797705334433	0.5622156269764178	0.40632999999999997	0.53882	4.091010387001303	7.154542922973633	1.0506899909690541	2.323410961248544	77.24177999999998	1.431396093541865	1.55	1.589
Story image method	Storygen	mix	0.3161447697738714	0.6174406043365306	0.351345	0.5696899999999999	3.862157754022653	6.248496055603027	0.8871016321169144	2.4112486863337717	78.96239999999997	1.386516452247613	1.75	1.609
Story image method	Storygen	multi-image-condition	0.3964378580993121	0.5511043718115605	0.368865	0.4694600000000001	4.088393089239576	7.669743061065674	1.1782954223155646	2.2461190007472345	78.41159999999999	1.4878796219461552	1.65	1.641
Story image method	Theatergen	base	0.22127979029796557	0.4108332606605389	0.30869	0.494925	4.943093551547452	13.60222053527832	2.848989681749563	1.9418985977417438	75.46481999999999	1.019353642913182	1.15	1.740
Story image method	UNO	base	0.4252279132950898	0.6476709030591131	0.4791199999999999	0.619115	5.134146589159491	10.501818656921387	3.5426490984722085	3.154869438190117	89.15778500000002	2.976098521089191	2.4	3.018
Story video method	Animdirector	base	0.30474287982877285	0.5578126908019243	0.3921	0.5559699999999999	5.602817362159187	9.942073822021484	3.6219595779014235	2.93239941855771	87.488885	3.3877672439986384	2.8	3.186
Story video method	MM-StoryAgent	base	0.260646784908524	0.6610337692876433	0.3215250000000001	0.456495	5.910447238281568	8.08989143371582	2.9652480089036617	2.451733500128027	78.6156	1.6427407613444138	1.55	2.152
Story video method	Movieagent	ROICtrl version	0.23556336642102646	0.5641415112759924	0.318715	0.4809949999999999	4.688716209096285	10.060813903808594	1.2842578910472544	2.71971197551781	82.384515	1.5840528898935522	1.45	1.760
Story video method	Movieagent	SD-3 version	0.3463104314315807	0.5394762768122299	0.398145	0.52879	5.317916726975183	12.044097900390625	3.4060093773288926	3.052264256670946	87.16789000000001	3.4043559047688796	2.75	3.153
Story video method	Vlogger	img ref	0.29873224302851936	0.49683442516467025	0.338055	0.521625	4.2423392681012855	8.827468872070312	1.7490488408686882	3.143481963094176	81.69142500000001	2.4285985097963447	2.5	2.455
Story video method	Vlogger	text only	0.2399230221601775	0.461644385398891	0.330675	0.47372500000000006	4.239843533080441	8.408939361572266	1.7068683537200346	3.0026457506687687	82.50404499999999	2.4042053394413805	2.3	2.353
Commercial platform	AIbrm	base	0.4119241335369471	0.7301968506213766	0.5359999999999999	0.7151599999999999	5.721231180444674	9.533270835876465	3.559543900182536	3.0539868060197035	91.20456499999997	2.5315472302536817	2.2	2.836
Commercial platform	Doubao	base	0.3667196448523748	0.6953917675281609	0.40302	0.577725	5.614623487140416	9.880890846252441	3.9765109890109884	3.2282410960575403	86.72837	3.7695832629876485	3.0	3.494
Commercial platform	MOKI	base	0.2143891023428912	0.6942679650121957	0.29793499999999995	0.510175	5.79427846610829	10.35705852508545	2.883243776842105	1.8766390469552452	79.78650999999999	0.9362761853847201	1.05	1.687
Commercial platform	Morphic_Studio	base	0.5770729221789919	0.6282115527996976	0.5491	0.6622263157894736	4.956604086668612	9.00381851196289	3.362877966443109	3.072559567111117	80.56904736842105	2.656330181173504	2.3684210526315788	2.865
Commercial platform	Nanobanana	gemini-2.5-flash-image-preview	0.44672421679887026	0.6573281325588987	0.521445	0.61913	5.61158233147516	10.544873237609863	3.9401214856572	3.238692282172827	91.92071499999997	3.6845615207165268	2.85	3.428
Commercial platform	ShenBi	base	0.27458533657066353	0.575265148158746	0.36499444444444445	0.5179055555555556	5.069995526721984	11.600507736206055	3.787412323164484	2.805579041393487	86.06453888888888	3.4540776875164823	2.611111111111111	3.165
Commercial platform	Typemovie	base	0.32503674908851066	0.6463776901015273	0.43263000000000007	0.54356	5.3206825973338105	11.154728889465332	2.863123670060397	3.0015774932604495	81.72819499999999	2.6048044595817723	2.4	2.717
MLLM model	Gemini	base	0.3610458450214631	0.5728793735502764	0.38635789473684207	0.529042105263158	4.906427097248973	9.304136276245117	3.5450598209922264	3.257475084839166	86.08922631578947	3.2224690450191154	2.5789473684210527	3.151
MLLM model	GPT4o	base	0.48076559836023247	0.6800785608705486	0.5714882352941176	0.6789588235294116	5.4904276566751316	9.793889999389648	3.9238693193803877	3.670952616187645	93.54235294117646	3.792668902871794	3.176470588235294	3.641
Naive baseline	Naive baseline	base	0.7354121665805837	0.7699532723535889	0.9105599999999999	0.9929600000000001	4.393115067521561	5.462975025177002	0.6197527816788385	2.0756661142220025	100.0	0.8648122702616149	1.55	1.278
`.trim();


/**
 * @typedef {Object.<string, string>} DataRow
 * Represents a single row of data where keys are column headers.
 */

/**
 * @typedef {{headers: string[], data: DataRow[]}} ParsedTSVData
 * Represents the parsed TSV data, including headers and an array of data rows.
 */

// Define interfaces for better type checking in Astro's TypeScript environment
interface DataRow {
    [key: string]: string;
}

interface ParsedTSVData {
    headers: string[];
    data: DataRow[];
}

/**
 * Parses a TSV string into an object containing headers and data rows.
 * @param {string} tsvString The TSV string to parse.
 * @returns {ParsedTSVData}
 */
function parseTSV(tsvString: string): ParsedTSVData {
    const lines = tsvString.trim().split('\n');
    const headers = lines[0].split('\t').map((h: string) => h.trim().replace(/^"|"$/g, '').replace(/\r$/, ''));
    const data = lines.slice(1).map((line: string) => {
        const values = line.split('\t');
        const row: DataRow = {};
        headers.forEach((header: string, index: number) => {
            // Ensure we don't try to access out-of-bounds values if a data row has fewer columns than headers
            row[header] = values[index] ? values[index].trim().replace(/^"|"$/g, '').replace(/\r$/, '') : '';
        });
        return row;
    });
    return { headers, data };
}

const fullResults = parseTSV(fullDatasetTSV);
const liteResults = parseTSV(liteDatasetTSV);

// Store other JSON data for potential future use (filters, charts)
const benchmarkClassData = { /* Paste benchmarkClassData JSON here if needed by client script */ };
const bestOfModeData = {
    "Storyadapter":"(Img ref)(scale0)",
    "Storydiffusion":"(Img ref) (photomaker)",
    "Storygen":"Multi-image-condition",
    "Movieagent":"SD-3 version",
    "Vlogger":"text only"
};

---
<BaseLayout title={pageTitle} activeNav={currentNav}>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <div class="container mx-auto px-4 py-8">
        <section id="charts-section" class="mb-8 p-6 bg-white dark:bg-slate-800 shadow-lg rounded-lg">
            <div class="flex flex-col md:flex-row justify-between items-center mb-4 gap-4">
                <h2 class="text-2xl font-semibold text-gray-700 dark:text-slate-200" data-lang-key="charts_title">Method Comparison Radar Charts</h2>
                <div class="flex items-center space-x-4">
                    <div class="flex items-center">
                        <input id="best-of-method-checkbox" type="checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 dark:border-slate-600 dark:focus:ring-indigo-500 dark:checked:bg-indigo-500">
                        <label for="best-of-method-checkbox" class="ml-2 block text-sm text-gray-900 dark:text-slate-300" data-lang-key="best_of_method_toggle">Best of Method Mode</label>
                    </div>
                    <div id="radar-mode-toggle-buttons" class="flex space-x-2 mr-4">
                        <button id="radar-lite-mode-btn" class="px-4 py-2 rounded font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 bg-gray-200 text-gray-700 hover:bg-gray-300 dark:bg-slate-600 dark:text-slate-300 dark:hover:bg-slate-500" data-lang-key="button_lite_mode">Lite Mode</button>
                        <button id="radar-full-mode-btn" class="px-4 py-2 rounded font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 bg-gray-200 text-gray-700 hover:bg-gray-300 dark:bg-slate-600 dark:text-slate-300 dark:hover:bg-slate-500" data-lang-key="button_full_mode">Full Mode</button>
                    </div>
                </div>
            </div>
            <div id="radar-charts-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-2 gap-6">
                {/* Radar charts will be dynamically added here */}
            </div>
        </section>

        <section id="detailed-leaderboard-section" class="p-6 bg-white dark:bg-slate-800 shadow-lg rounded-lg">
            <div class="flex flex-col sm:flex-row justify-between items-center mb-4 gap-4">
                <h2 class="text-2xl font-semibold text-gray-700 dark:text-slate-200" data-lang-key="leaderboard_detail_results">Results</h2>
                <div id="mode-toggle-buttons" class="flex space-x-2">
                    <button id="lite-mode-btn" class="px-4 py-2 rounded font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 bg-gray-200 text-gray-700 hover:bg-gray-300 dark:bg-slate-600 dark:text-slate-300 dark:hover:bg-slate-500" data-lang-key="button_lite_mode">Lite Mode</button>
                    <button id="full-mode-btn" class="px-4 py-2 rounded font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 bg-gray-200 text-gray-700 hover:bg-gray-300 dark:bg-slate-600 dark:text-slate-300 dark:hover:bg-slate-500" data-lang-key="button_full_mode">Full Mode</button>
                </div>
            </div>
            <div class="overflow-x-auto">
                <table id="detailed-leaderboard-table" class="min-w-full bg-white dark:bg-slate-800">
                    <thead id="leaderboard-thead" class="bg-gray-200 dark:bg-slate-700 text-gray-600 dark:text-slate-300 uppercase text-sm leading-normal">
                        {/* Headers will be rendered by script */}
                    </thead>
                    <tbody id="leaderboard-tbody" class="text-gray-700 dark:text-slate-300 text-sm font-light">
                        {/* Rows will be rendered by script */}
                    </tbody>
                </table>
            </div>
        </section>
    </div>
</BaseLayout>

<script define:vars={{ fullResultsData: fullResults, liteResultsData: liteResults, bestOfModeData: bestOfModeData }}>
    let currentView = 'lite'; // 'lite' or 'full'
    /** @type {DataRow[]} */
    let activeDataset = liteResultsData.data;
    /** @type {string[]} */
    let activeHeaders = liteResultsData.headers;

    const liteModeBtn = /** @type {HTMLButtonElement | null} */ (document.getElementById('lite-mode-btn'));
    const fullModeBtn = /** @type {HTMLButtonElement | null} */ (document.getElementById('full-mode-btn'));
    const tableThead = /** @type {HTMLTableSectionElement | null} */ (document.getElementById('leaderboard-thead'));
    const tableTbody = /** @type {HTMLTableSectionElement | null} */ (document.getElementById('leaderboard-tbody'));
    const leaderboardTable = /** @type {HTMLTableElement | null} */ (document.getElementById('detailed-leaderboard-table'));

    let columnStats = {}; // To store min/max for numeric columns for color gradient
    let isBestOfMethodMode = false;
    const bestOfMethodCheckbox = /** @type {HTMLInputElement | null} */ (document.getElementById('best-of-method-checkbox'));

    let currentSystemTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';

    /**
     * Determines the column type based on header name and a sample value.
     * @param {string} header The header text.
     * @param {string} sampleValue A sample value from the column.
     * @returns {'number' | 'text'}
     */
    function getColumnType(header, sampleValue) {
        const numericHeaderKeywords = [
            'Score', 'Avg', 'OCCM', // General keywords for numeric data
            'CRef', 'SRef', 'Adh', 'Quality', 'Overall' // From original static table, if column names are similar
        ];
        const specificNumericHeaders = [
            "Cross CSD Score (Ref-Gen)", "Self CSD Score (Gen-Gen)",
            "Cross Cref Score (Ref-Gen)", "Self Cref Score (Gen-Gen)",
            "Aesthetics Score", "Inception Score",
            "Prompt Align (Scene)", "Prompt Align (Camera)",
            "Prompt Align (Character Existence|Number)", "Prompt Align (Global Character Action|Script)",
            "Prompt Align (Local/Single Character Action|Script)",
            "Prompt Align Avg", // For full data, as per user edit
            "Prompt Align Avg（Alignment score）", // For lite data, as per user edit
            "Prompt Align (Character Existence|Number) OCCM"
        ];

        if (specificNumericHeaders.includes(header)) {
            if (sampleValue && !isNaN(parseFloat(sampleValue)) && isFinite(Number(sampleValue))) {
                return 'number';
            }
        }
        // Fallback check using keywords if specific header not matched
        if (numericHeaderKeywords.some(keyword => header.includes(keyword))) {
             if (sampleValue && !isNaN(parseFloat(sampleValue)) && isFinite(Number(sampleValue))) {
                return 'number';
            }
        }
        // Default to text if not clearly numeric by header or value
        return 'text';
    }

    function calculateColumnStats() {
        columnStats = {};
        activeHeaders.forEach(header => {
            const sampleValue = activeDataset.length > 0 && activeDataset[0] ? activeDataset[0][header] : "";
            const type = getColumnType(header, sampleValue);
            if (type === 'number') {
                let min = Infinity;
                let max = -Infinity;
                activeDataset.forEach(row => {
                    const value = parseFloat(row[header]);
                    if (!isNaN(value)) {
                        if (value < min) min = value;
                        if (value > max) max = value;
                    }
                });
                if (min !== Infinity && max !== -Infinity) {
                    columnStats[header] = { min, max };
                }
            }
        });
    }

    function renderTable() {
        if (!tableThead || !tableTbody) return;
        tableThead.innerHTML = '';
        tableTbody.innerHTML = '';

        calculateColumnStats(); // Calculate min/max for color gradients

        const groupHeaderRow = document.createElement('tr');
        const headerRow = document.createElement('tr');

        // 从 main_rank.py 获取的维度信息
        const dimensions = {
            "Method": [], // Method, model, mode 不属于任何维度分组
            "model": [],
            "mode": [],
            "Character Consistency(CRef)": [
                "Cross Cref Score (Ref-Gen)", 
                "Self Cref Score (Gen-Gen)"
            ],
            "Style Consistency(SRef)": [
                "Cross CSD Score (Ref-Gen)", 
                "Self CSD Score (Gen-Gen)"
            ],
            "Prompt Alignment": [
                "Prompt Align (Scene)",
                "Prompt Align (Camera)",
                "Prompt Align (Character Existence|Number) OCCM", // Lite data specific
                "Prompt Align (Character Existence|Number)", // Full data specific
                "Prompt Align (Global Character Action|Script)",
                "Prompt Align (Local/Single Character Action|Script)",
                "Prompt Align Avg（Alignment score）", // Lite data specific
                "Prompt Align Avg" // Full data specific
            ],
            "Generative Quality": [
                "Aesthetics Score"
            ],
            "Diversity": [
                "Inception Score"
            ]
        };

        let currentGroup = "";
        let colspanCount = 0;
        let previousTh = null;

        activeHeaders.forEach((headerText, index) => {
            let groupNameForHeader = "";
            let isInAnyGroup = false;
            for (const group in dimensions) {
                if (dimensions[group].includes(headerText)) {
                    groupNameForHeader = group;
                    isInAnyGroup = true;
                    break;
                } else if (headerText === group) { // For Method, Model, Mode
                    groupNameForHeader = headerText;
                    isInAnyGroup = true;
                    break;
                }
            }
            // If not in any predefined group, use the header itself as group (for ungrouped metrics)
            if (!isInAnyGroup) {
                 groupNameForHeader = headerText;
            }

            const isNewDisplayGroup = groupNameForHeader !== currentGroup;
            let newGroupThGotBorder = false; // Flag: true if the new groupTh (in groupHeaderRow) gets a border

            if (isNewDisplayGroup) {
                if (previousTh) { // Finalize the colspan of the previous group's th in groupHeaderRow
                    previousTh.colSpan = colspanCount;
                }
                // Create the new groupTh for groupHeaderRow
                const groupTh = document.createElement('th');
                let groupThClass = "py-3 px-6 text-center bg-gray-300 dark:bg-slate-600 text-gray-700 dark:text-slate-200 uppercase text-sm leading-normal";
                
                if (previousTh) { // If this new groupTh is NOT the first one on the groupHeaderRow
                    groupThClass += " border-l border-gray-400 dark:border-slate-500";
                    newGroupThGotBorder = true; // Mark that this new group's header cell got a border
                }
                groupTh.className = groupThClass;
                groupTh.textContent = groupNameForHeader;
                groupHeaderRow.appendChild(groupTh);
                
                previousTh = groupTh; // This new groupTh is now the "previousTh" for the next potential group
                currentGroup = groupNameForHeader;
                colspanCount = 1; // Reset colspan for this new group
            } else { // Continuing an existing group in groupHeaderRow
                colspanCount++;
            }

            // Create the metric th for headerRow (the second row of headers)
            const th = document.createElement('th');
            th.className = "py-3 px-6 text-left cursor-pointer hover:bg-gray-300 dark:hover:bg-slate-600 whitespace-normal text-gray-600 dark:text-slate-300";
            
            const displayHeaderText = headerText.replace('\\n', ' '); 
            th.textContent = displayHeaderText;

            const sampleValue = activeDataset.length > 0 && activeDataset[0] ? activeDataset[0][headerText] : "";
            const columnType = getColumnType(headerText, sampleValue);
            th.dataset.sortable = columnType;
            th.dataset.columnIndex = String(index);
            
            const arrowSpan = document.createElement('span');
            arrowSpan.className = 'sort-arrow ml-1';
            th.appendChild(arrowSpan);

            th.addEventListener('click', () => sortTable(index, columnType));
            // headerRow.appendChild(th); // Deferred appending after border logic

            // Logic to add border to this metric `th` (in headerRow)
            if (isNewDisplayGroup) { // This metric `th` is the first in its display group
                const individualHeadersThatGetRowspan2 = ['Method', 'model', 'mode'];
                let currentGroupWillBeRowspan2 = false;
                // The group this `th` belongs to is `groupNameForHeader`.
                if (individualHeadersThatGetRowspan2.includes(groupNameForHeader)) {
                    // These groups (Method, model, mode) get rowspan=2 if their groupTh's colspan is 1.
                    // As they form their own groups, their colspanCount will effectively be 1 when their groupTh is processed.
                    currentGroupWillBeRowspan2 = true;
                }
                
                // If the groupTh for this group (in groupHeaderRow) received a border, 
                // AND this group is not a rowspan=2 type, then this metric th also gets a border.
                if (newGroupThGotBorder && !currentGroupWillBeRowspan2) {
                    th.classList.add("border-l", "border-gray-400", "dark:border-slate-500");
                }
            }
            
            headerRow.appendChild(th); // Append the metric th to headerRow
        });

        if (previousTh) { // Set colspan for the very last group in groupHeaderRow
            previousTh.colSpan = colspanCount;
        }
        
        // Correct removal of Method, model, mode from second header row
        // And ensure the first few group headers have rowspan=2
        const individualHeadersToRemoveFromSecondRow = ['Method', 'model', 'mode'];
        /** @type {HTMLTableCellElement[]} */
        let actualHeaderRowChildNodes = Array.from(headerRow.childNodes);
        
        activeHeaders.forEach((headerText, index) => {
            if (individualHeadersToRemoveFromSecondRow.includes(headerText)) {
                // Find the corresponding groupTh and set rowspan
                 Array.from(groupHeaderRow.childNodes).forEach(groupThNode => {
                    const groupTh = /** @type {HTMLTableCellElement} */ (groupThNode);
                    if (groupTh.textContent === headerText && parseInt(groupTh.getAttribute('colspan') || '1') === 1) { // Ensure it's the specific th, not a larger group
                        groupTh.rowSpan = 2;
                    }
                });
                // Remove the th from the actualHeaderRowChildNodes list if it exists for this header
                const thToRemove = actualHeaderRowChildNodes.find(th => th.dataset.columnIndex === String(index));
                if (thToRemove && headerRow.contains(thToRemove)) {
                    headerRow.removeChild(thToRemove);
                }
            }
        });


        tableThead.appendChild(groupHeaderRow);
        tableThead.appendChild(headerRow);
        if (leaderboardTable) updateSortIndicators(leaderboardTable, -1, 'asc'); 

        activeDataset.forEach((rowData, rowIndex) => {
            const tr = document.createElement('tr');
            tr.className = "border-b border-gray-200 dark:border-slate-700 hover:bg-gray-100 dark:hover:bg-slate-700/50"; // dark mode border and hover
            
            activeHeaders.forEach(header => {
                let shouldRenderCell = true;
                let calculatedRowspan = 1;

                if (header === 'Method') {
                    if (rowIndex > 0 && rowData['Method'] === activeDataset[rowIndex - 1]['Method']) {
                        shouldRenderCell = false;
                    } else {
                        for (let i = rowIndex + 1; i < activeDataset.length; i++) {
                            if (activeDataset[i]['Method'] === rowData['Method']) {
                                calculatedRowspan++;
                            } else {
                                break;
                            }
                        }
                    }
                } else if (header === 'model') {
                    if (rowIndex > 0 && 
                        rowData['Method'] === activeDataset[rowIndex - 1]['Method'] &&
                        rowData['model'] === activeDataset[rowIndex - 1]['model']) {
                        shouldRenderCell = false;
                    } else {
                        for (let i = rowIndex + 1; i < activeDataset.length; i++) {
                            if (activeDataset[i]['Method'] !== rowData['Method']) break; // Stop if method group changes
                            if (activeDataset[i]['model'] === rowData['model']) {
                                calculatedRowspan++;
                            } else {
                                break;
                            }
                        }
                    }
                }

                if (shouldRenderCell) {
                    const td = document.createElement('td');
                    let baseTdClass = "py-3 px-6 text-left align-top whitespace-normal text-gray-700 dark:text-slate-200"; // Changed nowrap to normal for all TDs

                    if (header === 'METHOD') { // Note: Original was 'METHOD', but data uses 'Method'. Assuming case-insensitivity or data consistency.
                        td.className = baseTdClass + " w-40"; 
                    } 
                    else if (header === 'MODEL') { // Similarly, 'MODEL' vs 'model'
                        td.className = baseTdClass + " w-20"; 
                    } else {
                        td.className = baseTdClass;
                    }

                    if (calculatedRowspan > 1) {
                        td.rowSpan = calculatedRowspan;
                    }

                    let cellValue = rowData[header] !== undefined ? String(rowData[header]) : '';
                    const columnType = getColumnType(header, cellValue);

                    if (columnType === 'number') {
                        const numericValue = parseFloat(cellValue);
                        if (!isNaN(numericValue)) {
                            const stats = columnStats[header];
                            let normalizedValue = 0.5; 
                            if (stats && stats.max !== stats.min) {
                                normalizedValue = (numericValue - stats.min) / (stats.max - stats.min);
                            }
                            normalizedValue = Math.max(0, Math.min(1, normalizedValue)); 
                            
                            const finalHue = normalizedValue * 120;

                            const isDarkMode = document.documentElement.classList.contains('dark');
                            if (isDarkMode) {
                                let darkSat = 60;
                                let darkLight = normalizedValue * 20 + 20; 
                                td.style.backgroundColor = `hsl(${finalHue}, ${darkSat}%, ${darkLight}%)`;
                            } else {
                                td.style.backgroundColor = `hsl(${finalHue}, 70%, 85%)`;
                            }
                            td.textContent = numericValue.toFixed(3);
                            td.classList.add('text-center');
                        } else {
                            td.textContent = cellValue; 
                        }
                    } else {
                        td.textContent = cellValue.replace('\n', ' ');
                    }
                    tr.appendChild(td);
                }
            });
            tableTbody.appendChild(tr);
        });
    }

    function updateButtonStyles() {
        if (!liteModeBtn || !fullModeBtn) return;

        const activeClasses = ['bg-blue-600', 'text-white', 'shadow-md'];
        // These are the light-mode specific classes for an inactive button which are part of its base HTML style
        const inactiveLightModeBaseClasses = ['bg-gray-200', 'text-gray-700', 'hover:bg-gray-300'];

        // Function to set a button to active state
        function setActive(button) {
            button.classList.remove(...inactiveLightModeBaseClasses); // Remove light-mode inactive classes
            // Ensure dark mode inactive classes are also not present if they were somehow added by mistake elsewhere
            button.classList.remove('dark:bg-slate-600', 'dark:text-slate-300', 'dark:hover:bg-slate-500');
            button.classList.add(...activeClasses);
        }

        // Function to set a button to inactive state
        function setInactive(button) {
            button.classList.remove(...activeClasses); // Remove active classes
            button.classList.add(...inactiveLightModeBaseClasses); // Add light-mode inactive classes
            // Dark mode inactive classes should be part of the button's base HTML class attribute
            // and will apply automatically via Tailwind's dark: selector if not overridden
        }

        if (currentView === 'lite') { // Lite is active
            setActive(liteModeBtn);
            setInactive(fullModeBtn);
        } else { // Full is active
            setActive(fullModeBtn);
            setInactive(liteModeBtn);
        }
    }

    /** @type {Object.<string, Chart>} */
    let radarChartInstances = {}; 
    const radarChartsContainer = document.getElementById('radar-charts-container');
    
    /** @type {Object.<string, {min: number, max: number}>} */
    let radarMetricsStats = {}; // To store min/max for each radar metric globally

    // getDynamicRadarMetrics remains the same
    function getDynamicRadarMetrics() {
        const excludedMetrics = ['ID', 'RowNumber']; 
        const metrics = activeHeaders.filter(header => {
            const sampleValue = activeDataset.length > 0 && activeDataset[0] ? activeDataset[0][header] : "";
            return getColumnType(header, sampleValue) === 'number' && !excludedMetrics.includes(header);
        });
        return metrics.sort(); 
    }

    /** Calculates min/max for each metric across the entire activeDataset */
    function calculateAllRadarMetricsStats(metrics) {
        radarMetricsStats = {}; // Reset
        metrics.forEach(metric => {
            let minVal = Infinity;
            let maxVal = -Infinity;
            let count = 0;
            activeDataset.forEach(row => {
                const value = parseFloat(row[metric]);
                if (!isNaN(value)) {
                    if (value < minVal) minVal = value;
                    if (value > maxVal) maxVal = value;
                    count++;
                }
            });
            if (count > 0) {
                 if (minVal === maxVal) { // All values for this metric are the same
                    radarMetricsStats[metric] = { min: minVal - 0.5, max: maxVal + 0.5 }; 
                    if (minVal === 0) radarMetricsStats[metric] = {min: -0.5, max: 0.5}; // avoid 0/0 if all are 0
                } else {
                    radarMetricsStats[metric] = { min: minVal, max: maxVal };
                }
            } else {
                 radarMetricsStats[metric] = {min: 0, max: 1}; // Default if no data for a metric
            }
        });
    }

    /**
     * @param {string} methodName
     * @param {DataRow[]} modelRowsDataForMethod - All rows for the current method
     * @param {string[]} radarMetricsForChart
     */
    function prepareSingleRadarData(methodName, modelRowsDataForMethod, radarMetricsForChart) {
        const datasets = [];
        let modelsToProcess = modelRowsDataForMethod;

        if (isBestOfMethodMode) {
            const filteredModelRows = [];
            const processedModels = new Set(); // To ensure each model is added once for its best mode

            modelRowsDataForMethod.forEach(row => {
                const modelName = row.model;
                if (processedModels.has(modelName)) return; // Already processed the best mode for this model

                if (bestOfModeData[modelName]) { // If this model has a "best mode" defined
                    if (row.mode === bestOfModeData[modelName]) {
                        filteredModelRows.push(row);
                        processedModels.add(modelName);
                    }
                } else { // If no best mode defined for this model, include all its modes
                    // This logic might need refinement: if we want ALL modes of unlisted models,
                    // or just the first one we encounter after best-of-method filtering.
                    // For now, let's assume unlisted models should pass through all their modes when BoM is on.
                    // This actually means we should iterate over unique models first.
                }
            });
            
            // Revised logic for Best of Method:
            // 1. Get unique models within this method.
            // 2. For each unique model, find its best mode if defined, or take all its modes.
            const uniqueModelNamesInMethod = [...new Set(modelRowsDataForMethod.map(r => r.model))];
            const finalRowsForChart = [];

            uniqueModelNamesInMethod.forEach(modelName => {
                const bestModeForThisModel = bestOfModeData[modelName];
                if (bestModeForThisModel) {
                    const bestRow = modelRowsDataForMethod.find(r => r.model === modelName && r.mode === bestModeForThisModel);
                    if (bestRow) finalRowsForChart.push(bestRow);
                    // If bestRow not found (e.g. data inconsistency), it won't be added.
                } else {
                    // If model not in bestOfModeData, include all its modes for this method
                    const allModesForThisModel = modelRowsDataForMethod.filter(r => r.model === modelName);
                    finalRowsForChart.push(...allModesForThisModel);
                }
            });
            modelsToProcess = finalRowsForChart;
        }

        modelsToProcess.forEach((modelRow, index) => {
            const modelName = modelRow.model;
            const modeName = modelRow.mode;
            const label = `${modelName} (${modeName})`;
            const originalValues = {}; 

            const normalizedDataValues = radarMetricsForChart.map(metric => {
                const rawValue = parseFloat(modelRow[metric]);
                originalValues[metric] = !isNaN(rawValue) ? rawValue : "N/A";
                
                const stats = radarMetricsStats[metric];
                if (isNaN(rawValue) || !stats) return 0; 
                if (stats.max === stats.min) return 0.5; 
                
                const normalized = (rawValue - stats.min) / (stats.max - stats.min);
                return Math.max(0, Math.min(1, normalized)); 
            });

            const colorIndex = index % 10; 
            const backgroundColor = [
                'rgba(255, 99, 132, 0.2)', 'rgba(54, 162, 235, 0.2)', 'rgba(255, 206, 86, 0.2)', 
                'rgba(75, 192, 192, 0.2)', 'rgba(153, 102, 255, 0.2)', 'rgba(255, 159, 64, 0.2)',
                'rgba(199, 199, 199, 0.2)', 'rgba(83, 102, 255, 0.2)', 'rgba(40, 159, 64, 0.2)', 'rgba(210, 99, 132, 0.2)'
            ][colorIndex];
            const borderColor = [
                'rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)', 
                'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)',
                'rgba(199, 199, 199, 1)', 'rgba(83, 102, 255, 1)', 'rgba(40, 159, 64, 1)', 'rgba(210, 99, 132, 1)'
            ][colorIndex];

            datasets.push({
                label: label,
                data: normalizedDataValues,
                _originalValues: originalValues, 
                backgroundColor: backgroundColor,
                borderColor: borderColor,
                borderWidth: 1.5,
                pointBackgroundColor: borderColor,
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: borderColor
            });
        });

        return {
            labels: radarMetricsForChart.map(m => m.replace(" (Ref-Gen)", "").replace(" (Gen-Gen)", "").replace(" Score", "").replace("Prompt Align ", "PA: ").substring(0, 15)),
            datasets: datasets
        };
    }

    function renderOrUpdateAllRadarCharts() {
        if (!radarChartsContainer) return;
        radarChartsContainer.innerHTML = ''; 
        Object.values(radarChartInstances).forEach(instance => instance.destroy());
        radarChartInstances = {};

        const radarMetricsForChart = getDynamicRadarMetrics();
        if (radarMetricsForChart.length === 0) {
            radarChartsContainer.textContent = 'No numeric data available for radar charts.';
            return;
        }
        
        calculateAllRadarMetricsStats(radarMetricsForChart); // Calculate min/max for EACH metric globally

        const methods = [...new Set(activeDataset.map(row => row.Method))]
            .filter(method => method !== 'Naive baseline');

        if (methods.length === 0) {
            radarChartsContainer.textContent = 'No methods available to display radar charts (excluding Naive baseline).';
            return;
        }

        methods.forEach((methodName, chartIndex) => {
            const methodDataRows = activeDataset.filter(row => row.Method === methodName);
            if (methodDataRows.length === 0) return;

            const chartId = `radarChart-${methodName.replace(/\s+/g, '-').toLowerCase()}-${chartIndex}`;
            const canvasContainer = document.createElement('div');
            canvasContainer.className = 'relative h-96 md:h-[44rem] p-2 border dark:border-slate-700 rounded-md bg-white dark:bg-slate-800'; // Dark mode for canvas container
            
            const title = document.createElement('h3');
            title.className = 'text-md font-semibold text-center mb-2 text-gray-700 dark:text-slate-200'; // Dark mode for title
            title.textContent = methodName;
            canvasContainer.appendChild(title);

            const canvas = document.createElement('canvas');
            canvas.id = chartId;
            canvasContainer.appendChild(canvas);
            radarChartsContainer.appendChild(canvasContainer);

            const chartData = prepareSingleRadarData(methodName, methodDataRows, radarMetricsForChart);
            const ctx = canvas.getContext('2d');

            if (ctx) {
                // 为每个指标创建带有范围的标签
                const formattedLabels = radarMetricsForChart.map((metric, i) => {
                    const stats = radarMetricsStats[metric];
                    const shortName = metric.replace(" (Ref-Gen)", "").replace(" (Gen-Gen)", "").replace(" Score", "").replace("Prompt Align ", "PA: ").substring(0, 15);
                    return {
                        text: shortName,
                        min: stats ? stats.min.toFixed(2) : "N/A",
                        max: stats ? stats.max.toFixed(2) : "N/A"
                    };
                });

                radarChartInstances[methodName] = new Chart(ctx, {
                    type: 'radar',
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        elements: { line: { tension: 0.05 } },
                        layout: {
                            padding: {
                                top: 0,
                                bottom: 30 // 减少底部内边距，让图例上移
                            }
                        },
                        scales: {
                            r: {
                                angleLines: { display: true },
                                suggestedMin: 0,       // R-axis now 0 to 1 for normalized data
                                suggestedMax: 1,
                                pointLabels: { 
                                    font: { 
                                        size: 12, 
                                        family: "'PingFang SC', 'Helvetica Neue', Arial, sans-serif",
                                        weight: 500 
                                    },
                                    color: document.documentElement.classList.contains('dark') ? '#e2e8f0' : '#333333', // Changed to slate-200 for dark
                                    callback: function(label, index) {
                                        const formattedLabel = formattedLabels[index];
                                        return [
                                            formattedLabel.text,
                                            `[${formattedLabel.min} - ${formattedLabel.max}]`
                                        ];
                                    }
                                }, 
                                ticks: { 
                                    backdropColor: 'transparent', 
                                    stepSize: 0.2,
                                    font: {
                                        size:15,
                                        family: "'PingFang SC', 'Helvetica Neue', Arial, sans-serif"
                                    },
                                    color: document.documentElement.classList.contains('dark') ? '#cbd5e1' : '#666666'  // Changed to slate-300 for dark
                                } 
                            }
                        },
                        plugins: {
                            legend: { 
                                display: true, 
                                position: 'bottom', 
                                labels: {
                                    boxWidth: 12, 
                                    font: {
                                        size: 12,
                                        family: "'PingFang SC', 'Helvetica Neue', Arial, sans-serif",
                                        weight: 500
                                    },
                                    color: document.documentElement.classList.contains('dark') ? '#e2e8f0' : '#333333', // Changed to slate-200 for dark
                                    padding: 10
                                }
                            },
                            tooltip: {
                                titleFont: {
                                    size: 20,
                                    family: "'PingFang SC', 'Helvetica Neue', Arial, sans-serif",
                                },
                                bodyFont: {
                                    size: 20,
                                    family: "'PingFang SC', 'Helvetica Neue', Arial, sans-serif",
                                },
                                titleColor: document.documentElement.classList.contains('dark') ? '#e2e8f0' : '#333333', // 暗色模式用浅色，亮色模式用深色
                                bodyColor: document.documentElement.classList.contains('dark') ? '#e2e8f0' : '#333333', // 暗色模式用浅色，亮色模式用深色
                                backgroundColor: document.documentElement.classList.contains('dark') ? 'rgba(30, 41, 59, 0.95)' : 'rgba(255, 255, 255, 0.95)', // 暗色模式用深色背景，亮色模式用白色背景
                                borderColor: document.documentElement.classList.contains('dark') ? 'rgba(71, 85, 105, 0.9)' : 'rgba(156, 163, 175, 0.8)', // 暗色模式用深灰边框，亮色模式用浅灰边框
                                borderWidth: 1,
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        const metricName = radarMetricsForChart[context.dataIndex];
                                        
                                        // Access original values stored in the dataset
                                        const originalValue = context.dataset._originalValues[metricName]; 
                                        
                                        if (originalValue !== undefined && originalValue !== "N/A") {
                                            label += `${Number(originalValue).toFixed(3)} (normalized: ${context.parsed.r.toFixed(2)})`;
                                        } else if (originalValue === "N/A") {
                                            label += `N/A (normalized: ${context.parsed.r.toFixed(2)})`;
                                        } else {
                                            label += context.parsed.r.toFixed(2); // Fallback to normalized if original not found
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            }
        });
    }

    function renderAll() {
        calculateColumnStats(); 
        renderTable();
        renderOrUpdateAllRadarCharts(); 
    }

    bestOfMethodCheckbox?.addEventListener('change', (event) => {
        isBestOfMethodMode = event.target.checked;
        renderOrUpdateAllRadarCharts(); // Re-render only charts as table data doesn't change
    });

    const radarLiteModeBtn = /** @type {HTMLButtonElement | null} */ (document.getElementById('radar-lite-mode-btn'));
    const radarFullModeBtn = /** @type {HTMLButtonElement | null} */ (document.getElementById('radar-full-mode-btn'));

    function updateRadarButtonStyles() {
        if (!radarLiteModeBtn || !radarFullModeBtn) return;

        const activeClasses = ['bg-blue-600', 'text-white', 'shadow-md'];
        const inactiveLightModeBaseClasses = ['bg-gray-200', 'text-gray-700', 'hover:bg-gray-300'];

        function setActive(button) {
            button.classList.remove(...inactiveLightModeBaseClasses);
            button.classList.remove('dark:bg-slate-600', 'dark:text-slate-300', 'dark:hover:bg-slate-500');
            button.classList.add(...activeClasses);
        }

        function setInactive(button) {
            button.classList.remove(...activeClasses);
            button.classList.add(...inactiveLightModeBaseClasses);
        }

        if (currentView === 'lite') {
            setActive(radarLiteModeBtn);
            setInactive(radarFullModeBtn);
        } else {
            setActive(radarFullModeBtn);
            setInactive(radarLiteModeBtn);
        }
    }

    function updateAllButtonStyles() {
        updateButtonStyles();
        updateRadarButtonStyles();
    }

    radarLiteModeBtn?.addEventListener('click', () => {
        if (currentView === 'lite') return;
        currentView = 'lite';
        activeDataset = liteResultsData.data;
        activeHeaders = liteResultsData.headers;
        updateAllButtonStyles();
        renderAll();
    });

    radarFullModeBtn?.addEventListener('click', () => {
        if (currentView === 'full') return;
        currentView = 'full';
        activeDataset = fullResultsData.data;
        activeHeaders = fullResultsData.headers;
        updateAllButtonStyles();
        renderAll();
    });

    liteModeBtn?.addEventListener('click', () => {
        if (currentView === 'lite') return;
        currentView = 'lite';
        activeDataset = liteResultsData.data;
        activeHeaders = liteResultsData.headers;
        updateAllButtonStyles();
        renderAll();
    });

    fullModeBtn?.addEventListener('click', () => {
        if (currentView === 'full') return;
        currentView = 'full';
        activeDataset = fullResultsData.data;
        activeHeaders = fullResultsData.headers;
        updateAllButtonStyles();
        renderAll();
    });

    document.addEventListener('DOMContentLoaded', () => {
        if (bestOfMethodCheckbox) {
            isBestOfMethodMode = bestOfMethodCheckbox.checked; // Initialize from checkbox state if needed
        }
        updateAllButtonStyles();
        renderAll(); // Initial render

        // Observe theme changes to re-render components
        const observer = new MutationObserver((mutationsList, observer) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    const newTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
                    if (newTheme !== currentSystemTheme) {
                        currentSystemTheme = newTheme;
                        // Theme has changed, re-render all dynamic parts
                        renderAll(); 
                    }
                }
            }
        });

        observer.observe(document.documentElement, { attributes: true });
    });

    /** @type {Object.<number, 'asc' | 'desc'>} */
    let sortDirection = {}; 

    /**
     * Sorts the table by a given column index and type.
     * @param {number} columnIndex The index of the column to sort by.
     * @param {'number' | 'text'} type The data type of the column.
     */
    function sortTable(columnIndex, type) {
        if (!leaderboardTable || !tableTbody) return;
        
        // The current sorting sorts DOM elements. This means rowspans and styles will move with rows.
        // We need to ensure values extracted for sorting are correct.
        let rows = Array.from(tableTbody.querySelectorAll('tr'));

        const currentSortDir = sortDirection[columnIndex] === 'asc' ? 'desc' : 'asc';
        sortDirection = { [columnIndex]: currentSortDir }; 

        rows.sort((a, b) => {
            // Get the correct cell for comparison, accounting for potential rowspans.
            // This is tricky if sorting is done on already-rendered, rowspan-affected table.
            // For simplicity, the current sort extracts from the first cell available at that index.
            // A more robust sort would sort `activeDataset` then re-render.
            // However, let's try to make current DOM sort work better:
            
            const headerKey = activeHeaders[columnIndex]; // Get header name for the column
            // Find the actual row data for 'a' and 'b' based on a unique attribute if possible, or rely on order.
            // This is complex. For now, assume a.cells[columnIndex] and b.cells[columnIndex] give *some* cell.
            // The value for sorting should come directly from `activeDataset` if we map rows back to data items.
            // This is a limitation of sorting the DOM directly with rowspans from other columns.

            // Simplified: The current sortTable sorts based on visible cell content.
            // This might be non-ideal for merged cells but is the current mechanism.
            const cellA = /** @type {HTMLTableCellElement | null} */ (a.cells[columnIndex]);
            const cellB = /** @type {HTMLTableCellElement | null} */ (b.cells[columnIndex]);
            
            let valA, valB;

            if (type === 'number') {
                valA = parseFloat(cellA?.textContent?.trim() || 'NaN');
                valB = parseFloat(cellB?.textContent?.trim() || 'NaN');
                if (isNaN(valA)) valA = currentSortDir === 'asc' ? Infinity : -Infinity; // Push NaNs to bottom/top
                if (isNaN(valB)) valB = currentSortDir === 'asc' ? Infinity : -Infinity;
            } else { 
                valA = cellA?.textContent?.trim().toLowerCase() || '';
                valB = cellB?.textContent?.trim().toLowerCase() || '';
            }

            if (valA < valB) return currentSortDir === 'asc' ? -1 : 1;
            if (valA > valB) return currentSortDir === 'asc' ? 1 : -1;
            return 0;
        });

        rows.forEach(row => tableTbody.appendChild(row)); // Re-append sorted rows
        if (leaderboardTable) updateSortIndicators(leaderboardTable, columnIndex, currentSortDir);
    }
    /**
     * Updates the sort indicators in the table headers.
     * @param {HTMLTableElement} table The table element.
     * @param {number} activeColumnIndex The index of the currently sorted column.
     * @param {'asc' | 'desc'} direction The sort direction.
     */
    function updateSortIndicators(table, activeColumnIndex, direction) {
        if (!table) return;
        table.querySelectorAll('thead th[data-sortable]').forEach(thElement => {
            const th = /** @type {HTMLTableCellElement} */ (thElement);
            const arrow = th.querySelector('.sort-arrow');
            if (!arrow) return;
            if (th.dataset.columnIndex && parseInt(th.dataset.columnIndex) === activeColumnIndex) {
                arrow.textContent = direction === 'asc' ? ' ▲' : ' ▼';
            } else {
                arrow.textContent = '';
            }
        });
    }
</script> 